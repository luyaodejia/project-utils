题目来源和解析

https://blog.csdn.net/qq_41701956/article/details/100074023



### 1.什么情况下会发生栈内存溢出。(必背)

(自己回答)

​    堆中 方法区  常量池 程序计数器 方法栈	虚拟机栈

​    在参数  在修改参数的情况，栈的深度无法进行生成 会抛出oom异常



​		未申请题目类型  这个问的是栈内存溢出   而不是jvm所以的栈溢出情况     回答也正确

------

（参考资料）解答：

​	思路：描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，ok的话可以给面试官手写一个栈溢出的demo

- ​	栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作树栈，动态链接，方法出口等信息，局部变量表又包含基本数据类型，对象引用类型

- 若java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前java虚拟机栈的最大深度的时候，就抛出StackOvenFlowError

- 若java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法动态扩展了，此时抛出OutOfMemoryError错误

- 参数 -Xss 去调整JVM栈的大小

- 简单的栈溢出demo

  ```java
  public class StackOverFlowTest {
      public static void main(String[] args) {
          test();
      }
      public static void test(){
          test();
      }
  }
  ```

  



### 2.详解JVM内存模型(必背)

​	

​	堆内存   分为新生代 和老年代    新生代还可以进行细分为  Eden   SurvivorFrom 空间  Survivorto空间     



（参考资料）解答：

​	**思路：** 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。

![image-20200612162712871](assets/image-20200612162712871.png)

程序计算器（PC寄存器）： 当前线程所执行的字节码行号指示器，用于记录正在执行的虚拟机字节码指令地址，线程私有

java虚拟机栈： 存放基本数据类型，对象引用，方法出口等信息，线程私有

Native方法栈:  和虚拟机相似，只不过它服务于Native方法，线程私有

java堆（堆内存）：是jvm所管理最大一块内存区域，所以对象实例，数组都存放在java堆上，GC回收的地方，线程共享

方法区: 存放已被加载的类信息，常量，静态变量，即时编译器编译后的代码数据等（即永久代），回收目标主要是常量池的回收和类型的卸载，各线程共享

### 3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

自己解答：（组织语言能力太差 ）

这个要从垃圾回收角度来讲：

​	新生代主要的特点是：新增对象快，垃圾回收频繁  采用的是复制算法

​	老年代主要的特点是: 对象存活年限长，垃圾回收周期比较长，一般是是内存不足的时候才触发老年的垃圾回收机制  采用的是标记回收算法 或者标记整理算法

持久代：主要是存放class文件

因为新生代的垃圾回收频繁  所以hostsprt虚拟机采用的是复制算法，复制算法有一个特点，

分为Eden 和survivor from  和survivor to  它们的比例为8:1:1  

​	首先Eden 空间 它的新增对象快  然后经过minorGc回收  如果Eden空间还存活着引用值，就会年龄+1，存放到Survivor 空间  并且survivor to 清空  

思路： 先讲一下java堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如 -xx:NewRatio,-XXSurvivorRation等），再解释为什么要这样划分，最好加一点自己的理解

1)  内存划分

​	java堆=新生代+老年代

​	新生代=Eden空间+S0+S1

2）一些参数的配置

​	默认的，新生代（young）与老年代（Old）的比例的值为1:2  可以通过参数 -XX：newRatio 配置

​	默认的：Edem：from :to  的比例是8:1:1 

3）为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

 如果没有Survivor，Eden区每进行一次MinorGC，存活的对象就会被送到老年代，老年代很快被填满，触发MajorGC ,老年代的内存空间远大于新生代，进行一次full GC消耗的时间比Minor GC长的多（10倍），所以需要分为Eden和Survivor



### 4.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

​		一次完整的GC流程是 MinorGc+FullGC  分别是新生代垃圾回收和老年代垃圾回收

​		



### 5.你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。





### 6.JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。





### 7.简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。





### 8.说说你知道的几种主要的JVM参数





### 9.怎么打出线程栈信息。







### 10.强引用、软引用、弱引用、虚引用的区别？

   强引用：主要是java中常用的引用，类似于new Object()的引用  这类为强引用  ，不容易被回收

​	软引用:  主要特点是，当堆内存不足的时候，才会进行回收 

​	弱引用：主要特点是  不管堆内存足够不足够，只要进行了解回收就会被回收掉

​	虚引用:  主要特点是  一闪而过，一般这类引用只作为虚拟机栈的引用 





https://www.cnblogs.com/JesseP/p/11750847.html