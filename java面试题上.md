git 提交操作   https://www.cnblogs.com/cxk1995/p/5800196.html



面试流程：https://segmentfault.com/a/1190000016132561

**面试经验提炼（有帮助）https://segmentfault.com/a/1190000021254273**



hashcode原理讲解  https://www.cnblogs.com/sheseido/p/12098263.html





https://blog.csdn.net/jackfrued/article/details/44921941

**解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。**

答：通常我们定义一个基本数据类型的变量，一个对象的引用，函数调用的现场保存都使用jvm的栈空间  

​	通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以分为新生代和老生代，方法区和堆都是各个线程共享的内存区域，用于存储已经被jvm加载的类信息，常量，静态变量，jit编译后的代码等数据 

如直接书写的100，hello和常量都是放在常量池中，常量池是方法区的一部分，栈空间操作起来最快，但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过jvm的启动参数来进行调整，栈空间用光了会引发stackOverFlowError,而堆和常量池空间不足会引发outOFMemoryError

**重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？**

答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。
**21、描述一下JVM加载class文件的原理机制？**

jvm中类的装载是由类加载器加载和他的子类来实现的，负责运行时查找装入类文件的类

由于java的跨平台性，经过编译的java源程序并不是一个可执行程序，而是一个和多个类文件，当java程序需要某个类时:jvm会确保这个类已经被加载（验证，准备和解析）和初始化。

类被加载后就进入连接阶段，这一阶段包括验证，准备（为静态变量分配内存并设置默认的初始化值） 和解析（将符号引用替换为直接引用）三个步骤，最后jvm对类进行初始化



类的加载是由类的加载器完成的，类加载器包括，根加载器(bootstrap),扩展加载器（Extension）,系统加载器(System) 和自定义类加载器（java.lang.ClassLoader的子类）

30、GC是什么？为什么要有GC？

gc是垃圾收集的意思，主要是进行内存回收    

标记回收机制

可到达性回收机制



**Java 中的final关键字有哪些用法？**

答:修饰类：表示该类不能被继承

​	修饰方法：表示该方法不能被重写

​	修饰变量: 表示该变量只能一次赋值以后不能被修改



**45、Error和Exception有什么区别？**

error表示系统级错误Exception表示程序运行错误





## 多线程

程序：是指令和数据的文件，被存储在磁盘或其他手段数据库存储设备中

进程：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序即是一个进程从创建，运行到消亡的过程

线程: 线程与进程相似，但线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程，与进程不同的是同类的多个线程共享进程的堆和方法区，但每个线程有自己的程序计数器，虚拟机栈，和本地方法栈 所以系统产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，也正是因为如此，线程也被称为轻量级进程



### 图解进程和线程的关系

​	一个进程可以有多个线程，多个线程共享进程的方法区和堆内存（jdk1.8之后的元空间）资源，但是每个线程都有自己独立的  程序计算器，本地方法栈 ，虚拟机栈

 线程是进程划分成更小的运行单位，线程和进程最大的不同在于基本上进程是独立的，而各线程则不一定是独立的，因为同一进程中的线程可能会相互影响，线程执行开销小，但不利于资源的管理和保护，而进程正相反



### 2.2. 程序计数器为什么是私有的?

​		程序计数器主要有下面两个作用:

​		1: 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流转控制，如顺序执行，选择，循环，异常处理

​		2: 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道线程上次运行到哪儿了

​	所以:程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

### 2.3. 虚拟机栈和本地方法栈为什么是私有的?

​		虚拟机栈: 每个java方法在执行的同时会创建一个栈帧用户存储局部变量表，操作数栈，常量池引用等信息，从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程

​	本地方法栈: 和虚拟机所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行java方法（也就是字节码)服务，而本地方法栈则为虚拟机使用到nativen方法服务

​	所以:  为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的

### 2.4. 一句话简单了解堆和方法区

​	堆和方法区是所以线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象(几乎所以的对象都在这里分配内存)，方法区主要用于存放已被加载的类信息，常量，静态变量，即时编译器后的代码等数据



## 3. 说说并发与并行的区别?

并发: 同一时间段，多个任务都在执行（单位时间内部一定同时执行）

并行: 单位时间内，多个任务同时执行



## 4. 为什么要使用多线程呢?

先从总体上来说:

​	从计算机底层来说:  线程可以比作轻量级的进程，是程序执行最小的单位，线程间的切换和调度的成本远远小于进程，另外，多核cpu时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销

从当代互联网发展趋势来说: 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能





## 说说 sleep() 方法和 wait() 方法区别和共同点?

​	两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁

​	两者都可以暂停线程的执行

​	wait通常被用于线程间交互/通信，sleep通常被用于暂停执行

​	wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll（）方法 唤醒线程,sleep（）方法执行完成后 线程会自动苏醒  或者可以使用wait（long timeout)超时后线程会自动苏醒

## 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？

​		new 一个Thread，线程进入新建状态，调用start（）方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以执行了，start（）会执行线程相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作。而直接执行run（）方法，会把run方法当成一个main线程下的普通方法区执行，并不会在某个线程执行它，所以这并不是多线程工作

​	总结;调用start方法可启动线程并使线程进入就绪状态，而run方法只是main



# 剖析面试最常见问题之Java集合框架



### 1.1.1 说说List,Set,Map三者的区别？

List（对付顺序的好帮手）：List接口存储一组不唯一（可以有多个元素引用相同的对象）有序的UI小

Set（注重独一无二的性质):不允许重复的集合，不会有多个元素引用相同的对象

Map（用key来搜索的专家): 使用键值对存储，map会维护与key有关联的值，两个key可以引用相同的对象，但可以不能重复，典型的key是String类型，也可以是任何对象



### 集合框架底层数据结构总结（Collection）

list 

​	ArrayList： object 数组

​	Vector：Object数组

​	LinkedList：双向链表（jdk1.6之前为循环链表，jdk1.7取消循环）

​	

set

​	HashSet(无序，唯一)：基于HashMap实现的，底层采用HashMap来保护元素

​	LinkedHashSet: LinkedHashSet 继承HashSet，并且其内部是通过LinkedHashMap来实现的，有点类似于我们之前说的LinkedHashMap，其内部是基于HashMap实现一样，不过还是有一点点区别

TreeSet（有序  唯一）：红黑树（自平衡的排序的二叉树）



Map

​	HashMap；jdk之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。jdk1.8以后在解决哈希冲突有了较大的变化，当链表长度大于阈值（默认为8）将链表转换成红黑树  如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时将链表转化为红黑树，以减少搜索时间

​	LinkedHashMap：LinkedHashMap 继承自HashMap,所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成，另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链接进行相应的操作，实现了访问顺序相关逻辑

HashTable : 数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的

TreeMap ：红黑树（自平衡的排序二叉树）

### ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？

Vector类的所有方法都是同步的，可以由两个线程安全的访问一个Vector对象，但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间



### 说一说 ArrayList 的扩容机制吧

 初始化量为10   



HashMap原理解析:https://segmentfault.com/a/1190000021123143?utm_source=tag-newest

### HashMap 和 Hashtable 的区别

1：线程是否安全: HashMap 是非线程安全的，Hashtable是线程安全的，HashTable内部的方法基本都经过synchronize 修饰  (如果你要保证线程安全的话就使用ConcurrentHashMap吧)

2: 效率: 因为线程安全的问题，HashMap要比HashTabl效率高一点，另外，HashTable基本被淘汰，不要在代码中使用它

3：对Null  key  和 Null value 的支持：HashMap中，null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为null，但是在HashTable中put进的键值只要一个null，直接抛出NullPointerException    

4: 初始容量大小和每次扩充容量大小的不同:  创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩容，容量变为原来的2n+1，HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍，创建时如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而hashmap总是使用2的幂作为哈希表的大小

5： 底层数据结构： jdk1.8以后的Hashmap在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换红黑树时），将链表转换红黑树，以减少搜索时间，hashtable没有这样的机制



### HashMap 和 HashSet区别

HashSet是基于HashMap实现的 

![image-20200608144104168](C:\Users\hnrsPC\AppData\Roaming\Typora\typora-user-images\image-20200608144104168.png)





### ConcurrentHashMap 和 Hashtable 的区别

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

底层数据结构: jdk1.7 d concurrentHashMap 底层采用分段的数组+链表实现，jdk1.8采用数据结构跟HashMap的结构一样，数组+链表/红黑二叉树，HashTable和jdk1.8之前的HashMap的底层结构类似都是采用数组+链表的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的

实现线程安全的方式(重要): 在jdk1.7的时候， ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率， 到了jdk1.8的时候已经弃用了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作，

HashTable(同一把锁): 使用synchronized来保证线程安全，效率非常低下，当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低



# Java 并发基础常见面试题总结

​	什么是线程和进程?

​		进程：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序即是一个进程从创建，运行到消亡的过程

 在java中，当我们启动main函数时其实就是启动了一个jvm的进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程

​		线程: 线程和进程相似，但是线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程，与进程不同的是同类的多个线程共享进程的堆和方法区资源是，但每个线程的有自己的程序计数器，虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，



## 请简要描述线程与进程的关系,区别及优缺点？

**从 JVM 角度说进程和线程之间的关系**

​		总结：运行时数据区域，一个进程中可以有多个线程，多个线程共享进程的堆和方法区（jdk1.8之后的元空间)资源，但是每个线程有自己的程序设计器，虚拟机栈和本地方法栈

​				线程是进程划分成的更小的运行单位，线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响，线程执行开销小，但不利于资源的管理和保护，而进程正相反(进程独立，执行开销相对于线程而言比较大，有效对资源管理和保护)



为什么**程序计数器**、**虚拟机栈**和**本地方法栈**是线程私有的呢？为什么堆和方法区是线程共享的呢？

​	首先说作用:

​	程序计算器主要有下面两个作用：

​			1: 通过字节码解释器来改变程序计数器来依次读取指令，从而实现代码的流转控制，如 顺序执行，选择，循环，异常处理

​			2: 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿去了

 所以：程序计数器私有主要是为了线程切换后能恢复到正确的执行位置

### 虚拟机栈和本地方法栈为什么是私有的?

​	每个java方法在执行的同时创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等信息，从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程

本地方法栈，：和虚拟机线所发挥的作用相似，区别是: 虚拟机栈为虚拟机执行java方法服务，而本地方法中栈则为虚拟机使用到Native方法服务，在HotSpot虚拟机中和java虚拟机栈合二为一

所以，为了保证线程中局部变量不被别的线程访问到，虚拟机栈合本地栈是线程私有的



### 一句话简单了解堆和方法区

堆和方法区是所以线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（几乎所以对象都在这里分配内存，方法区主要用于存放已被加载的类信息，常量，静态变量，即时编译器后的代码等数据）



## 说说线程的生命周期和状态?

​		new  初始状态，线程被构建，但是还没有调用start()方法  （未执行阶段）

​		runnable  运行状态，java线程将操作系统中的就绪和运行两种状态笼统称为“运行中”

​		blocked  阻塞状态，表示线程阻塞于锁

​		waiting  等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)

​		time_waiting  超时等待状态，该状态不同于waiting，它是可以在指定的时间自行返回的

​		terminated 终止状态，表示当前线程已经执行完毕

 ![image-20200608174826415](C:\Users\hnrsPC\AppData\Roaming\Typora\typora-user-images\image-20200608174826415.png)

























































